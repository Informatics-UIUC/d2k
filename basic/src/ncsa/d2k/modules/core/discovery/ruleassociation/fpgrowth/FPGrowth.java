/*
 * $Header$
 *
 * ===================================================================
 *
 * D2K-Workflow
 * Copyright (c) 1997,2006 THE BOARD OF TRUSTEES OF THE UNIVERSITY OF
 * ILLINOIS. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License v2.0
 * as published by the Free Software Foundation and with the required
 * interpretation regarding derivative works as described below.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License v2.0 for more details.
 *
 * This program and the accompanying materials are made available
 * under the terms of the GNU General Public License v2.0 (GPL v2.0)
 * which accompanies this distribution and is available at
 * http://www.gnu.org/copyleft/gpl.html (or via mail from the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA  02110-1301, USA.), with the special and mandatory
 * interpretation that software only using the documented public
 * Application Program Interfaces (APIs) of D2K-Workflow are not
 * considered derivative works under the terms of the GPL v2.0.
 * Specifically, software only calling the D2K-Workflow Itinerary
 * execution and workflow module APIs are not derivative works.
 * Further, the incorporation of published APIs of other
 * independently developed components into D2K Workflow code
 * allowing it to use those separately developed components does not
 * make those components a derivative work of D2K-Workflow.
 * (Examples of such independently developed components include for
 * example, external databases or metadata and provenance stores).
 *
 * Note: A non-GPL commercially licensed version of contributions
 * from the UNIVERSITY OF ILLINOIS may be available from the
 * designated commercial licensee RiverGlass, Inc. located at
 * (www.riverglassinc.com)
 * ===================================================================
 *
 */
package ncsa.d2k.modules.core.discovery.ruleassociation.fpgrowth;


import ncsa.d2k.core.modules.PropertyDescription;
import ncsa.d2k.modules.core.discovery.ruleassociation.ItemSets;

import java.beans.PropertyVetoException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.TreeSet;
import ncsa.d2k.modules.core.util.*;


/**
 * <p>Title:</p>
 *
 * <p>Description: This module implements the FPGrowth algorithm to generate
 * frequent itemsets consisting of items that occur in a sufficient number of
 * examples to satisfy the minimum support criteria.</p>
 *
 * <p>Detailed Description: This module takes an <i>Item Sets</i> object that
 * has been generated by a <i>Table To Item Sets</i> module and uses the
 * FPGrowth algorithm to find the combinations of items that satisfy a minimum
 * support criteria. An item is an [attribute,value] pair that occurs in the set
 * of examples being mined. The user controls the support criteria via the <i>
 * Minimum Support %</i> property that specifies the percentage of all examples
 * that must contain a given combination of items before that combination is
 * included in the generated output. Each combination of items that satisfies
 * the <i>Minimum Support %</i> is called a <i>Frequent Itemset</i>.</p>
 *
 * <p>The user can restrict the maximum number of items included in any frequent
 * itemset with the <i>Maximum Items Per Rule</i> property. The generation of
 * sets with large number of items can be computationally expensive, so setting
 * this property in conjunction with the <i>Minimum Support %</i> property helps
 * keep the module runtime reasonable.</p>
 *
 * <p>In a typical itinerary the <i>Frequent Item Sets</i> output port from this
 * module is connected to a <i>Compute Confidence</i> module which forms
 * association rules that satisfy a minimum confidence value.</p>
 *
 * <p>References: For more information on the FPGrowth frequent pattern mining
 * algorithm, see &quot;Mining Frequent Patterns without Candidate
 * Generation&quot;Jiawei Han, Jian Pei, and Yiwen Yin, 2000.</p>
 *
 * <p>Limitations: The <i>FPGrowth</i> and <i>Compute Confidence</i> modules
 * currently build rules with a single item in the consequent.</p>
 *
 * <p>Data Type Restrictions: While this module can operate on attributes of any
 * datatype, in practice it is usually infeasible to use it with
 * continuous-valued attributes. The module considers each [attribute,value]
 * pair that occurs in the examples individually when building the frequent
 * itemsets. Continuous attributes (and categorical attributes with a large
 * number of values) are less likely to meet the Minimum Support requirements
 * and can result in unacceptably long execution time. Typically <i>Choose
 * Attributes</i> and <i>Binning</i> modules should appear in the itinerary
 * prior to the <i>Table to Item Sets</i> module, whose output produces the <i>
 * Item Sets</i> object used as input by this module. The Choosing/Binning
 * modules can reduce the number of distinct [attribute,value] pairs that must
 * be considered in this module to a reasonable number.</p>
 *
 * <p>Data Handling: This module does not modify the input Item Sets in any way.
 * </p>
 *
 * <p>Scalability: This module creates an array of integers to hold the indices
 * of the items in each frequent itemset. The module may be computationally
 * intensive, and scales with the number of Item Sets entries to search. The
 * user can limit the size of the frequent itemsets although this will have
 * little effect on performance for this algorithm. Choosing and Binning modules
 * can be included in the itinerary prior to this modules to reduce the number
 * of Item Sets entries.</p>
 *
 * <p>Copyright: Copyright (c) 2006</p>
 *
 * <p>Company:</p>
 *
 * @author  not attributable
 * @version 1.0
 */
public class FPGrowth extends ncsa.d2k.core.modules.ComputeModule {

   //~ Static fields/initializers **********************************************

   /** Use serialVersionUID for interoperability. */
   static private final long serialVersionUID = -7565706965121174249L;

   //~ Instance fields *********************************************************

   /** The discovered frequent patterns that meet the support criteria. */
   private ArrayList _patterns = null;


   /**
    * the verbosity property. If this property is true, the module will report
    * progress information to the console.
    */
   private boolean _verbose = true;

   /**
    * the Debug property. Is sets to true, this module outpus debug information
    * to stdout.
    */
   private boolean debug = false;

   /** the maximum number of attributes that will be included in any rule. */
   private int maxSize = 6;

   /**
    * this is the number of sets that must contain a given rule for it (the
    * rule) to meet the support.
    */
   int cutoff;


   /**
    * this property is the min acceptable support, expressed as a percentage.
    */
   double support = 20.0;

   //~ Constructors ************************************************************

   /**
    * Creates a new FPGrowth object.
    */
   public FPGrowth() { }

   //~ Methods *****************************************************************

   /**
    * Creates all available pattern combinations using the nodes in <codE>
    * list</codE>. e.g. if list is [A,B,C] then the patterns to be added are AB,
    * BC, AC, ABC (order does not matter)
    *
    * @param list  A List of FPTreeNode objects
    * @param alpha Indices of columns in original table that take part int his
    *              rule.
    */
   private void combos2(List list, int[] alpha) {
      int pattern_len;
      int i;
      int[] ind = new int[list.size() + 1];
      pattern_len = list.size();

      if (pattern_len > 0) {

         // initialize index
         while (ind[pattern_len] == 0) {

            // adjust index
            i = 0;
            ind[i]++;

            while (ind[i] > 1) {
               ind[i] = 0;
               ind[++i]++;
            }

            if (ind[pattern_len] == 0) {
               FPPattern pat = new FPPattern(alpha, 0);
               int min = Integer.MAX_VALUE;

               for (i = pattern_len - 1; i >= 0; i--) {

                  if (ind[i] == 1) {
                     FPTreeNode nd = (FPTreeNode) list.get(i);
                     pat.addPatternElt(nd.getLabel());

                     if (nd.getCount() < min) {
                        min = nd.getCount();
                     }
                  }
               }

               pat.setSupport(min);
               _patterns.add(pat);
            }
         } // end while
      } // end if
   } // end method combos2


   /**
    * Builds an FPTree from the input items sets and discovers frequent
    * patterns, that are stored in <codE>_patterns.</code>
    *
    * @param prob Serves as the data for the root of the FPTree to be created by
    *             this method.
    */
   private void FPProcess(FPProb prob) {


      FPTreeNode root = new FPTreeNode(-1, null, -1, -1);

      int[] alpha = prob.getAlpha();
      FPSparse tab = prob.getTable();
      int support = prob.getSupport();

      // Build header table
      TreeSet tfeats = new TreeSet(new Feature_Comparator());

      for (int i = 0, n = tab.getNumColumns(); i < n; i++) {
         int coltot = tab.getColumnTots(i);

         if (coltot >= support) {
            tfeats.add(new FeatureTableElement(tab.getLabel(i), coltot, i));
         }
      }

      // trim the list
      ArrayList headers = new ArrayList();
//      boolean b = true;

      for (Iterator it = tfeats.iterator(); it.hasNext();) {
         FeatureTableElement fte = (FeatureTableElement) it.next();

         headers.add(fte);
      }

      int leafcnt = 0;

      // build the FPTree
      for (int i = 0, n = tab.getNumRows(); i < n; i++) {
         FPTreeNode current = root;

         for (int j = 0, m = headers.size(); j < m; j++) {
            FeatureTableElement fte = (FeatureTableElement) headers.get(j);
            int val = tab.getInt(i, fte.getPosition());

            if (val > 0) {
               FPTreeNode next = current.getChild(fte.getLabel());

               if (next == null) {

                  if (current.isRoot() || (current.getNumChildren() > 0)) {
                     leafcnt++;
                  }

                  next = new FPTreeNode(fte.getLabel(), current, val, j);

                  fte.addPointer(next);
                  current.addChild(next);
               } else {
                  next.inc(val);
               }

               current = next;
            }
         }
      } // end for


      // If the tree is null, return
      if (leafcnt == 0) {
         return;
      }


      // If the tree has only one path, ouput all pattern combinations union
      // alpha.
      if (leafcnt == 1) {
         ArrayList path = new ArrayList();
         FPTreeNode cpathnode =
            (FPTreeNode) ((Object[]) root.getChildren().getValues())[0];

         while (true) {
            path.add(cpathnode);

            if (cpathnode.getNumChildren() == 0) {
               break;
            }

            cpathnode =
               (FPTreeNode) ((Object[]) cpathnode.getChildren().getValues())[0];
         }

         // now we need to get the combinations.
         ArrayList param = new ArrayList(path);

         // int supp =  ((FPTreeNode)path.get(path.size()-1)).getCount();
         combos2(param, alpha);

         return;
      }


      // else, take each feature from header table (in reverse support order)
      // and output that feature|union alpha as a pattern, create a new patterns
      // DB, create new FPProb, and finally call FPProcess.
      for (int a = headers.size() - 1; a >= 0; a--) {

         FeatureTableElement fte = (FeatureTableElement) headers.get(a);
         List ptrs = fte.getPointers();

         // add the entry in the table union alpha
         FPPattern pat = new FPPattern(alpha, fte.getCnt());
         pat.addPatternElt(fte.getLabel());
         _patterns.add(pat);

         FPSparse otab = new FPSparse(headers.size());
         int[] colmap = new int[headers.size()];
         int cind = 1;

         // create new pattern DB
         int cnter = 0;

         for (int i2 = 0, n2 = ptrs.size(); i2 < n2; i2++) {
            FPTreeNode node = (FPTreeNode) ptrs.get(i2);
            List l = this.getPath(node);

            for (int i3 = 0, n3 = l.size(); i3 < n3; i3++) {
               FPTreeNode node2 = (FPTreeNode) l.get(i3);

               if (colmap[node2.getPosition()] == 0) {
                  otab.addColumn(((FeatureTableElement) headers.get(node2
                                                                       .getPosition()))
                                    .getLabel());
                  colmap[node2.getPosition()] = cind;
                  cind++;
               }

               otab.setInt(node.getCount(), cnter, colmap[node2.getPosition()] -
                           1);
            }

            if (l.size() > 0) {
               cnter++;
            }
         }

         // build a new prob and submit it for processing
         int[] newalpha = new int[alpha.length + 1];
         System.arraycopy(alpha, 0, newalpha, 0, alpha.length);
         newalpha[newalpha.length - 1] = fte.getLabel();

         FPProb newprob = new FPProb(otab, newalpha, support);
         FPProcess(newprob);
      } // for a

   } // FPProcess


   /**
    * Returns a list of FPTreeNode objects, that is the path from <codE>
    * node</code> to the root of the tree. The returned list won't contain the
    * root or the node itself. Thus if <codE>node</code> is a direct child of
    * the root or the root itself - then the returned value is an empty list.
    *
    * @param  node A data node int he the FPTree created by <code>
    *              FPPRocess</codE> method.
    *
    * @return A List of FPTreeNode objects, that is the path from <codE>
    *         node</code> to the root of the tree. The returned list won't
    *         contain the root or the node itself. Thus if <codE>node</code> is
    *         a direct child of the root or the root itself - then the returned
    *         value is an empty list.
    */
   private List getPath(FPTreeNode node) {
      ArrayList list = new ArrayList();

      if (node.isRoot()) {
         return list;
      }

      node = node.getParent();

      while (true) {

         if (node.isRoot()) {
            return list;
         }

         list.add(node);
         node = node.getParent();
      }
   }


   /**
    * Performs the main work of the module. *
    *
    * @throws Exception if a problem occurs while performing the work of the
    *                   module.
    */

   protected void doit() throws java.lang.Exception {

      long start = System.currentTimeMillis();

      try {

         ItemSets iss = (ItemSets) this.pullInput(0);
         HashMap sNames = iss.unique;
 //        int[] targetIndices = iss.targetIndices;
         String[] nameAry = iss.names;
         int numExamples = iss.numExamples;

         cutoff = (int) ((double) numExamples * (support / 100.0));

         if (((double) numExamples * (support / 100.0)) > (double) cutoff) {
            cutoff++;
         }

         // BUILD INITIAL PROBLEM
         FPProb prob = null;

         boolean[][] vals = iss.getItemFlags();
         FPSparse tab = new FPSparse(nameAry.length);
         FPPattern.clearElementMapping();

         for (int i = 0, n = nameAry.length; i < n; i++) {
            tab.addColumn(i);
            FPPattern.addElementMapping(i, nameAry[i]);
         }

         for (int i = 0, n = vals.length; i < n; i++) {

            for (int j = 0, m = vals[i].length; j < m; j++) {

               if (vals[i][j] == true) {
                  tab.setInt(1, i, j);
               }
            }
         }

         int[] flist = new int[0];
         prob = new FPProb(tab, flist, cutoff);

         _patterns = new ArrayList();


         FPProcess(prob);

         myLogger.info("\n\n" + _patterns.size() +
                 " patterns discovered.");

         long stop = System.currentTimeMillis();
         myLogger.info((stop - start) / 1000 + " seconds");;


         int numpatsout = 0;

         gnu.trove.TIntIntHashMap tiihm = new gnu.trove.TIntIntHashMap();

         for (int i = 0, n = _patterns.size(); i < n; i++) {
            FPPattern pat = (FPPattern) _patterns.get(i);
            int sz = pat.getSize();
            int val = tiihm.get(sz);
            val++;
            tiihm.put(sz, val);
         }

         int[] keys = tiihm.keys();

         for (int i = 0, n = keys.length; i < n; i++) {

            if ((keys[i] < 2) || (keys[i] > this.getMaxRuleSize())) {
               numpatsout += tiihm.get(keys[i]);

               continue;
            }

            myLogger.info("Number of frequent " + keys[i] + "-patterns: " +
                    tiihm.get(keys[i]));
         }

         // CONVERT TO FORMAT USED BY COMPUTE CONFIDENCE MODULE

         int totnum = _patterns.size() - numpatsout;

         int[][] ovals = new int[totnum][];
         int ocnt = 0;

         for (int i = 0, n = _patterns.size(); i < n; i++) {
            FPPattern pat = (FPPattern) _patterns.get(i);

            if (
                (pat.getSize() < 2) ||
                   (pat.getSize() > this.getMaxRuleSize())) {
               continue;
            }

            int[] fp = new int[pat.getSize() + 1];
            int cnter = 0;

            for (gnu.trove.TIntIterator it = pat.getPattern(); it.hasNext();) {
               fp[cnter++] = (int) it.next();
            }

            fp[cnter] = pat.getSupport();
            ovals[ocnt++] = fp;
         }

         if (totnum != ocnt) {
        	 myLogger.equals("Error: counts not right for total patterns output -- expected " +
                     totnum + " -- produced " + ocnt);
         }

         if (_patterns.size() > 0) {
            this.pushOutput(ovals, 0);
         }

      } catch (Exception ex) {
         ex.printStackTrace();
         System.out.println(ex.getMessage());
         System.out.println("ERROR: FPTreeGrowth.doit()");
         throw ex;
      }
   } // end method doit

   private D2KModuleLogger myLogger;
   /**
    * Called by the D2K Infrastructure before the itinerary begins to execute.
    * Nulls the objects references.
    */
   public void beginExecution() {
	   _patterns = null; 
	   myLogger = D2KModuleLoggerFactory.getD2KModuleLogger(this.getClass());
   }

   /**
    * Called by the D2K Infrastructure after the itinerary completes execution.
    * Nulls the objects references.
    */
   public void endExecution() {
      super.endExecution();

      _patterns = null;
   }

   /**
    * Returns the debug property value.
    *
    * @return boolean The debug property value.
    */
   public boolean getDebug() { return this.debug; }


   /**
    * Returns a description of the input at the specified index.
    *
    * @param  inputIndex Index of the input for which a description should be
    *                    returned.
    *
    * @return <code>String</code> describing the input at the specified index.
    */
   public String getInputInfo(int inputIndex) {

      switch (inputIndex) {

         case 0:
            return "An object produced by a <i>Table To Item Sets</i> module " +
                   "containing items that will appear in the frequent itemsets. ";

         default:
            return "No such input";
      }
   }


   /**
    * Returns the name of the input at the specified index.
    *
    * @param  inputIndex Index of the input for which a name should be returned.
    *
    * @return <code>String</code> containing the name of the input at the
    *         specified index.
    */
   public String getInputName(int inputIndex) {

      switch (inputIndex) {

         case 0:
            return "Item Sets";

         default:
            return "No such input.";
      }
   }

   /**
    * Returns an array of <code>String</code> objects each containing the fully
    * qualified Java data type of the input at the corresponding index.
    *
    * @return An array of <code>String</code> objects each containing the fully
    *         qualified Java data type of the input at the corresponding index.
    */

   public String[] getInputTypes() {
      String[] types =
      {
         "ncsa.d2k.modules.core.discovery.ruleassociation.ItemSets"
      };

      return types;
   }

   /**
    * Returns the maximum number of attributes allowed in any rule.
    *
    * @return int The maximum number of attributes allowed in any rule.
    */
   public int getMaxRuleSize() { return this.maxSize; }

   /**
    * Returns the value of the minumum support property.
    *
    * @return double The value of the minumum support property
    */
   public double getMinimumSupport() { return this.support; }


   /**
    * Describes the purpose of the module.
    *
    * @return <code>String</code> describing the purpose of the module.
    */
   public String getModuleInfo() {
      StringBuffer sb = new StringBuffer("<p>Overview: ");
      sb.append("This module implements the FPGrowth algorithm to generate frequent itemsets consisting of ");
      sb.append("items that occur in a sufficient number of examples to satisfy the minimum support criteria. ");

      sb.append("</p><p>Detailed Description: ");
      sb.append("This module takes an <i>Item Sets</i> object that has been generated by a <i>Table To Item Sets</i> ");
      sb.append("module and uses the FPGrowth algorithm to find ");
      sb.append("the combinations of items that satisfy a minimum support criteria. ");
      sb.append("An item is an [attribute,value] pair that occurs in the set of examples being mined. ");
      sb.append("The user controls the support criteria via the <i>Minimum Support %</i> property that specifies the ");
      sb.append("percentage of all examples that must contain a given combination of items ");
      sb.append("before that combination is included in the generated output. ");
      sb.append("Each combination of items that satisfies the <i>Minimum Support %</i> is called ");
      sb.append("a <i>Frequent Itemset</i>. ");

      sb.append("</p><p> ");
      sb.append("The user can restrict the maximum number of items included in any frequent itemset with ");
      sb.append("the <i>Maximum Items Per Rule</i> property.  The generation of sets with large number of items ");
      sb.append("can be computationally expensive, so setting this property in conjunction with the <i>Minimum Support %</i> ");
      sb.append("property helps keep the module runtime reasonable. ");

      sb.append("</p><p>");
      sb.append("In a typical itinerary the <i>Frequent Item Sets</i> output port from this module is connected to ");
      sb.append("a <i>Compute Confidence</i> module which forms ");
      sb.append("association rules that satisfy a minimum confidence value. ");

      sb.append("</p><p>References: ");
      sb.append("For more information on the FPGrowth frequent pattern mining algorithm, see &quot;Mining Frequent Patterns ");
      sb.append("without Candidate Generation&quot;Jiawei Han, Jian Pei, and Yiwen Yin, 2000. ");

      sb.append("</p><p>Limitations: ");
      sb.append("The <i>FPGrowth</i> and <i>Compute Confidence</i> modules currently ");
      sb.append("build rules with a single item in the consequent.  ");

      sb.append("</p><p>Data Type Restrictions: ");
      sb.append("While this module can operate on attributes of any datatype, in practice it is usually infeasible ");
      sb.append("to use it with continuous-valued attributes.   The module considers each [attribute,value] pair that occurs ");
      sb.append("in the examples individually when building the frequent itemsets.  Continuous attributes (and categorical ");
      sb.append("attributes with a large number of values) are less likely to meet the Minimum Support requirements ");
      sb.append("and can result in unacceptably long execution time.  Typically <i>Choose Attributes</i> and <i>Binning</i> ");
      sb.append("modules should appear in the itinerary prior to the <i>Table to Item Sets</i> module, whose output produces ");
      sb.append("the <i>Item Sets</i> object used as input by this module.   The Choosing/Binning modules can reduce the ");
      sb.append("number of distinct [attribute,value] pairs that must be considered in this module to a reasonable number. ");

      sb.append("</p><p>Data Handling: ");
      sb.append("This module does not modify the input Item Sets in any way. ");

      sb.append("</p><p>Scalability: ");
      sb.append("This module creates an array of integers to hold the indices of the items in each frequent itemset. ");
      sb.append("The module may be computationally intensive, and scales with the number of Item Sets entries to search. ");
      sb.append("The user can limit the size of the frequent itemsets although this will have little effect on performance for ");
      sb.append("this algorithm. Choosing and Binning modules can be included in the itinerary ");
      sb.append("prior to this modules to reduce the number of Item Sets entries.  </p>");

      return sb.toString();
   } // end method getModuleInfo

   /**
    * Returns the name of the module that is appropriate for end user
    * consumption.
    *
    * @return The name of the module.
    */

   public String getModuleName() { return "FPGrowth"; }


   /**
    * Returns a description of the output at the specified index.
    *
    * @param  outputIndex Index of the output for which a description should be
    *                     returned.
    *
    * @return <code>String</code> describing the output at the specified index.
    */
   public String getOutputInfo(int outputIndex) {

      switch (outputIndex) {

         case 0:

            String s =
               "A representation of the frequent itemsets found by the module. " +
               "This representation encodes the items used in the sets " +
               "and the number of examples in which each set occurs. This output is typically " +
               "connected to a <i>Compute Confidence</i> module.";

            return s;

         default:
            return "No such output";
      }
   }


   /**
    * Returns the name of the output at the specified index.
    *
    * @param  outputIndex Index of the output for which a name should be
    *                     returned.
    *
    * @return <code>String</code> containing the name of the output at the
    *         specified index.
    */
   public String getOutputName(int outputIndex) {

      switch (outputIndex) {

         case 0:
            return "Frequent Itemsets";

         default:
            return "No such output.";
      }
   }


   /**
    * Returns an array of <code>String</code> objects each containing the fully
    * qualified Java data type of the output at the corresponding index.
    *
    * @return An array of <code>String</code> objects each containing the fully
    *         qualified Java data type of the output at the corresponding index.
    */
   public String[] getOutputTypes() {
      String[] types = {
         "[[I"
      };

      return types;
   }


   /**
    * Returns an array of <code>ncsa.d2k.core.modules.PropertyDescription</code>
    * objects for each property of the module.
    *
    * @return An array of <code>ncsa.d2k.core.modules.PropertyDescription</code>
    *         objects.
    */
   public PropertyDescription[] getPropertiesDescriptions() {
      PropertyDescription[] pds = new PropertyDescription[4];
      pds[0] =
         new PropertyDescription("minimumSupport",
                                 "Minimum Support %",
                                 "The percent of all examples that must contain a given set of items " +
                                 "before an association rule will be formed containing those items. " +
                                 "This value must be greater than 0 and less than or equal to 100.");
      pds[1] =
         new PropertyDescription("maxRuleSize",
                                 "Maximum Items per Rule",
                                 "The maximum number of items to include in any rule. Does not impact performance for this algorithm as it does for Apriori." +
                                 "This value cannot be less than 2.");
      pds[2] =
         new PropertyDescription("verbose",
                                 "Generate Verbose Output",
                                 "If this property is true, the module will report progress information to the console.");
      pds[3] =
         new PropertyDescription("debug",
                                 "Generate Debug Output",
                                 "If this property is true, the module will write verbose status information to the console.");

      return pds;
   }


   /**
    * Returns the value of the verbose property.
    *
    * @return boolean The value of the verbose property.
    */
   public boolean getVerbose() { return this._verbose; }

   /**
    * Sets the debug property value.
    *
    * @param yy boolean The value for the debug property.
    */
   public void setDebug(boolean yy) { this.debug = yy; }

   /**
    * Sets the maximum number of attributes allowed in any rule.
    *
    * @param  yy int The maximum number of attributes allowed in any rule.
    *
    * @throws PropertyVetoException if <codE>yy</code> is not greater than 1.
    */
   public void setMaxRuleSize(int yy) throws PropertyVetoException {

      if (yy < 2) {
         throw new PropertyVetoException(" Maximum Items per Rule cannot be less than 2.",
                                         null);
      }

      maxSize = yy;
   }

   /**
    * Sets the value of the minimum support property.
    *
    * @param  d double The value of the minimum support property.
    *
    * @throws PropertyVetoException if <code>d</code> is not in the range
    *                               [0,100]
    */
   public void setMinimumSupport(double d) throws PropertyVetoException {

      if (d <= 0.0 || 100.0 < d) {
         throw new PropertyVetoException(" Minimum Support % must be greater than 0 and less than or equal to 100.",
                                         null);
      }

      this.support = d;
   }

   /**
    * Sets the value of the verbose property.
    *
    * @param yy boolean The value for the verbose property.
    */
   public void setVerbose(boolean yy) { this._verbose = yy; }

   //~ Inner Classes ***********************************************************

   /**
    * <p>Title: Feature_Comparator</p>
    *
    * <p>Description: compares 2 FeatureTableElement objects</p>
    *
    * <p>Copyright: Copyright (c) 2006</p>
    *
    * <p>Company:</p>
    *

    * @version 1.0
    */
   private class Feature_Comparator implements java.util.Comparator {

      /**
       * The small deviation allowed in double comparisons.
       */

      /**
       * An empty constructor.
       */
      public Feature_Comparator() { }

      /**
       * Intrerface implementation. Returns 1 if according to the natural order
       * of FeatureTableElement <code>o1</code> is greater than <codE>o1</code>,
       * -1 it <code>o2</code> is greater than <code>o1</code> and 0 if they are
       * equal. The natural order of FeatureTableElement is derived from the
       * natural order of FeatureTableElement's count property (sumof data in
       * the original column): If the count properties are different the
       * returned value is <code>o1</codE>.count - <codE>o2</code>.count If the
       * counts are equals the natural order is derived from the natural order
       * of the FeatureTableElement's labels (The feature's index if all
       * features are ordered by frequency in the original table).
       *
       * @param  o1 Object is expected to be a FeatureTableElement object
       * @param  o2 Object is expected to be a FeatureTableElement object
       *
       * @return int 1 if according to the natural order of FeatureTableElement
       *         <code>o1</code> is greater than <codE>o1</code>, -1 it <code>
       *         o2</code> is greater than <code>o1</code> and 0 if they are
       *         equal.
       */
      public int compare(Object o1, Object o2) {
         FeatureTableElement fte1 = (FeatureTableElement) o1;
         FeatureTableElement fte2 = (FeatureTableElement) o2;

         if (fte1.getCnt() == fte2.getCnt()) {

            if (fte1.getLabel() > fte2.getLabel()) {
               return 1;
            } else if (fte1.getLabel() < fte2.getLabel()) {
               return -1;
            } else {
               System.out.println("ERROR ERROR ERROR: We never want to go here ...");

               return 0;
            }
         } else if (fte1.getCnt() > fte2.getCnt()) {
            return -1;
         } else {
            return 1;
         }
      }

      /**
       * Interface implementation. Compares <code>o</codE> with this comparator.
       *
       * @param  o an object to be compared with this ocmparator.
       *
       * @return true if <codE>o</code> is this comparator, otherwise returns
       *         false.
       */
      public boolean equals(Object o) { return this.equals(o); }
   } // end class Feature_Comparator


} // end class FPGrowth
