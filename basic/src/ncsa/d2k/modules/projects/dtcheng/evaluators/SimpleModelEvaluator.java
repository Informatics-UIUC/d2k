package ncsa.d2k.modules.projects.dtcheng.evaluators;

import ncsa.d2k.modules.projects.dtcheng.inducers.Model;
import ncsa.d2k.modules.projects.dtcheng.inducers.HistogramPDFModel;
import ncsa.d2k.modules.*;
import ncsa.d2k.modules.core.datatype.sort.*;
import ncsa.d2k.modules.core.prediction.*;
import ncsa.d2k.core.modules.*;
import ncsa.d2k.modules.core.datatype.parameter.*;
import ncsa.d2k.modules.core.datatype.parameter.impl.*;
import ncsa.d2k.modules.core.datatype.table.*;
import ncsa.d2k.modules.projects.dtcheng.inducers.ErrorFunction;
import ncsa.d2k.core.modules.PropertyDescription;
import java.beans.PropertyVetoException;
import ncsa.d2k.modules.projects.dtcheng.examples.*;
import java.util.Vector;

import java.text.*;

public class SimpleModelEvaluator
 extends OrderedReentrantModule {
  
  int numProperties = 11;
  public PropertyDescription[] getPropertiesDescriptions() {
    
    PropertyDescription[] pds = new PropertyDescription[numProperties];
    
    int i = 0;
    
    pds[i++] = new PropertyDescription(
     "reportPredictions",
     "Report  Predictions",
     "Report the predicted and actual values and errors for selected examples");
    
    pds[i++] = new PropertyDescription(
     "numberOfPredictionsToReport",
     "NumberOfPredictionsToReport",
     "NumberOfPredictionsToReport");
    
    pds[i++] = new PropertyDescription(
     "reportAverageError",
     "Report Average Error",
     "Report the average error over all examples");
    
    pds[i++] = new PropertyDescription(
     "filterByPredictedOutput",
     "Filter By Predicted Output",
     "When only the top and/or bottom fraction of the examples, ranked by predicted output, are used for error assessment");
    
    pds[i++] = new PropertyDescription(
     "filterOutputLowerFraction",
     "Filter Output Lower Fraction",
     "The lower fraction of examples, ranked by predicted output, to be used for error assessment");
    
    pds[i++] = new PropertyDescription(
     "filterOutputUpperFraction",
     "Filter Output Upper Fraction",
     "The upper fraction of examples, ranked by predicted output, to be used for error assessment");
    
    pds[i++] = new PropertyDescription(
     "reportLineLabel",
     "Report Line Label",
     "The label printed at the beginning of each report line");
    
    pds[i++] = new PropertyDescription(
     "errorIsNegativeAverageActualOutput",
     "Error Is Negative Average Actual Output",
     "Used with filtering for TTW");
    
    pds[i++] = new PropertyDescription(
     "weightErrorByTestingSetSize",
     "Weight Error By Testing Set Size",
     "Used when there are differently sized test sets as generated by grouped cross validation when a linear weight is desired");
    
    pds[i++] = new PropertyDescription(
     "weightErrorByLogTestingSetSize",
     "Weight Error By Log Testing Set Size",
     "Used when there are differently sized test sets as generated by grouped cross validation when a log weight is desired");
    
    pds[i++] = new PropertyDescription(
     "useGroupedAnalysis",
     "Use Grouped Analysis",
     "Used example groups when computing filtered results");
    
    return pds;
  }
  
  private boolean ReportPredictions = false;
  public boolean getReportPredictions() {
    return this.ReportPredictions;
  }
  public void setReportPredictions(boolean value) {
    this.ReportPredictions = value;
  }
  
  
  private int NumberOfPredictionsToReport = -1;
  public int getNumberOfPredictionsToReport() {
    return this.NumberOfPredictionsToReport;
  }
  public void setNumberOfPredictionsToReport(int value) {
    this.NumberOfPredictionsToReport = value;
  }
  
  
  private boolean WeightErrorByLogTestingSetSize = false;
  public void setWeightErrorByLogTestingSetSize(boolean value) {
    this.WeightErrorByLogTestingSetSize = value;
    if (value == true) {
      this.WeightErrorByTestingSetSize = false;
    }
  }
  
  public boolean getWeightErrorByLogTestingSetSize() {
    return this.WeightErrorByLogTestingSetSize;
  }
  
  
  private boolean WeightErrorByTestingSetSize = false;
  public void setWeightErrorByTestingSetSize(boolean value) {
    this.WeightErrorByTestingSetSize = value;
    if (value == true) {
      this.WeightErrorByLogTestingSetSize = false;
    }
  }
  
  public boolean getWeightErrorByTestingSetSize() {
    return this.WeightErrorByTestingSetSize;
  }
  
  
  private boolean errorIsNegativeAverageActualOutput = false;
  public void setErrorIsNegativeAverageActualOutput(boolean value) {
    this.errorIsNegativeAverageActualOutput = value;
  }
  
  public boolean getErrorIsNegativeAverageActualOutput() {
    return this.errorIsNegativeAverageActualOutput;
  }
  
   private boolean reportAverageError = false;
  public void setReportAverageError(boolean value) {
    this.reportAverageError = value;
  }
  
  public boolean getReportAverageError() {
    return this.reportAverageError;
  }
  
  private boolean filterByPredictedOutput = false;
  public void setFilterByPredictedOutput(boolean value) {
    this.filterByPredictedOutput = value;
  }
  
  public boolean getFilterByPredictedOutput() {
    return this.filterByPredictedOutput;
  }
  
  private double filterOutputLowerFraction = 0.2;
  public void setFilterOutputLowerFraction(double value) throws
   PropertyVetoException {
    
    if (value < 0.0) {
      throw new PropertyVetoException(" < 0.0", null);
    }
    
    if (value > 1.0) {
      throw new PropertyVetoException(" > 1.0", null);
    }
    
    if (value + filterOutputUpperFraction > 1.0) {
      throw new PropertyVetoException(" + filterOutputUpperFraction > 1.0", null);
    }
    
    this.filterOutputLowerFraction = value;
  }
  
  public double getFilterOutputLowerFraction() {
    return this.filterOutputLowerFraction;
  }
  
  private double filterOutputUpperFraction = 0.2;
  public void setFilterOutputUpperFraction(double value) throws PropertyVetoException {
    
    if (value < 0.0) {
      throw new PropertyVetoException(" < 0.0", null);
    }
    
    if (value > 1.0) {
      throw new PropertyVetoException(" > 1.0", null);
    }
    
    if (value + filterOutputLowerFraction > 1.0) {
      throw new PropertyVetoException(" + filterOutputLowerFraction > 1.0", null);
    }
    
    this.filterOutputUpperFraction = value;
  }
  
  public double getFilterOutputUpperFraction() {
    return this.filterOutputUpperFraction;
  }
  
  private String reportLineLabel = "SimpleModelEvaluator: ";
  public void setReportLineLabel(String value) {
    this.reportLineLabel = value;
  }

  
  public boolean useGroupedAnalysis = false;
  public void setUseGroupedAnalysis(boolean value) {
    this.useGroupedAnalysis = value;
  }
  public boolean getUseGroupedAnalysis() {
    return this.useGroupedAnalysis;
  }


  
  
  
  
  
  
  public String getReportLineLabel() {
    return this.reportLineLabel;
  }
  
  public String getModuleName() {
    return "Simple Model Evaluator";
  }
  
  public String getModuleInfo() {
    return "This module measures the predictive error of a model relative to the given error function and example set.  " +
     "If Filter by Predicted Output is true, then only a subset of the examples are used for the error measurement.  " +
     "This subset is selected by first applying the model to every example, sorting the examples based on predicted output, " +
     "and then selecting the top and/or bottom fraction of examples for error calculations.  ";
  }
  
  public String getInputName(int i) {
    switch (i) {
      case 0:
        return "Error Function";
      case 1:
        return "Model";
      case 2:
        return "Example Table";
    }
    return "";
  }
  
  public String getInputInfo(int i) {
    switch (i) {
      case 0:
        return "The error function to apply to predictions made by the model";
      case 1:
        return "The model used to make predictions";
      case 2:
        return "The examples to use for predictive error calculations";
    }
    return "";
  }
  
  public String[] getInputTypes() {
    String[] in = {
      "ncsa.d2k.modules.core.prediction.ErrorFunction",
      "java.lang.Object",
      "ncsa.d2k.modules.core.datatype.table.ExampleTable"};
    return in;
  }
  
  public String getOutputName(int i) {
    switch (i) {
      case 0:
        return "Objective Parameter Point";
      case 1:
        return "Prediction Table";
        
    }
    return "";
  }
  
  public String getOutputInfo(int i) {
    switch (i) {
      case 0:
        return "A point in objective space indicating the predictive error of model";
      case 1:
        return "The prediction table generated to analyze the results.";
    }
    return "";
  }
  
  public String[] getOutputTypes() {
    String[] out = {
      "ncsa.d2k.modules.core.datatype.parameter.ParameterPoint",
      "ncsa.d2k.modules.core.datatype.table.PredictionTable"};
    return out;
  }
  
  int invocationCount;
  public void beginExecution() {
    invocationCount = 0;
  }
  
  public void doit() throws Exception {
    
    ErrorFunction errorFunction = (ErrorFunction)this.pullInput(0);
    Object        modelObject   = (Object)this.pullInput(1);
    ExampleTable  exampleTable  = (ExampleTable)this.pullInput(2);
    
    ExampleTable examples = exampleTable;
    
    int numExamples = examples.getNumRows();
    int numInputs = examples.getNumInputFeatures();
    int numOutputs = examples.getNumOutputFeatures();
    
    // change to call make prediction
    
    //PredictionTable predictionTable = model.predict(exampleTable.copy());
    PredictionTable predictionTable = exampleTable.toPredictionTable();
    
    
    if (errorFunction.index != ErrorFunction.likelihoodErrorFunctionIndex) {
      ((PredictionModelModule) modelObject).predict(predictionTable);
    } else {
      
      
      for (int e = 0; e < numExamples; e++) {
        double logLikelihood = ((Model) modelObject).evaluateLogLikelihood(examples, e);
        predictionTable.setDoublePrediction(logLikelihood, e, 0);
      }
      
    }
    
    
    
    
    
    if (ReportPredictions) {
      
      
      DecimalFormat Format = new DecimalFormat();
      
      Format.setMaximumFractionDigits(9);
      
      int limit = NumberOfPredictionsToReport;
      if (NumberOfPredictionsToReport == -1)
        limit = numExamples;
      
      for (int e = 0; e < limit; e++) {
        for (int o = 0; o < numOutputs; o++) {
          //synchronized (System.out) {
//          System.out.println(reportLineLabel + "g = " + g + " o = " + o +
//           "  predicted = " + predictionTable.getDoublePrediction(g, o) +
//           "  actual = " + exampleTable.getOutputDouble(g, o));
          System.out.println(reportLineLabel + "\t" +
           invocationCount + "\t" +
           Format.format(predictionTable.getDoublePrediction(e, o)) + "\t" +
           exampleTable.getOutputDouble(e, o));
          //}
        }
      }
      
    }
    
    // mark examples to be used for error calculation
    boolean[] useExamples = null;
    if (filterByPredictedOutput) {
      
          useExamples = new boolean[numExamples];
          
      if (useGroupedAnalysis) {

        
        
        TchengExampleTable tchengExampleTable = (TchengExampleTable)exampleTable;
        
        
        // determine max group index //
        int maxGroupIndex = Integer.MIN_VALUE;
        for (int e = 0; e < numExamples; e++) {
          int group = tchengExampleTable.getGroup(e);
          if (group > maxGroupIndex) {
            maxGroupIndex = group;
          }
          
        }
        
        
        // create group example index vectors
        int       maxNumGroups  = maxGroupIndex + 1;        
        Vector [] groupExamples = new Vector[maxNumGroups];
        for (int g = 0; g < maxNumGroups; g++) {
          groupExamples[g] = new Vector();
        }        
        for (int e = 0; e < numExamples; e++) {
          int group = tchengExampleTable.getGroup(e);
          groupExamples[group].add(new Integer(e)); 
        }
        
        
        ////////////////////////////////////////////////////////////////////
        // marking examples to score for group based filtered predictions //
        ////////////////////////////////////////////////////////////////////
        
        for (int g = 0; g < maxNumGroups; g++) {
          
          int numGroupExamples = groupExamples[g].size();

          // sort each groups examples by predicted output value //
          double[][] results = new double[numGroupExamples][2];
          for (int e = 0; e < numGroupExamples; e++) {
            int actualExampleIndex = ((Integer)(groupExamples[g].elementAt(e))).intValue();
            double outputSum = 0.0;
            for (int o = 0; o < numOutputs; o++) {
              outputSum += predictionTable.getDoublePrediction(actualExampleIndex, 0);
            }
            double predicted = outputSum / numOutputs;
            
            results[e][0] = predicted;
            results[e][1] = actualExampleIndex;
          }
          
          QuickSort.sort(results);
          
          int lowerNumExamples = (int) Math.round(filterOutputLowerFraction * numGroupExamples);
          int upperNumExamples = (int) Math.round(filterOutputUpperFraction * numGroupExamples);
          
          for (int e = 0; e < lowerNumExamples; e++) {
            useExamples[(int) results[e][1]] = true;
          }
          for (int e = 0; e < upperNumExamples; e++) {
            useExamples[ (int) results[numGroupExamples - 1 - e][1]] = true;
          }
        }

        
      } else {
        
        double[][] results = new double[numExamples][2];
        for (int e = 0; e < numExamples; e++) {
          double outputSum = 0.0;
          for (int o = 0; o < numOutputs; o++) {
            outputSum += predictionTable.getDoublePrediction(e, 0);
          }
          double predicted = outputSum / numOutputs;
          
          results[e][0] = predicted;
          results[e][1] = e;
        }
        
        QuickSort.sort(results);
        
        int lowerNumExamples = (int) Math.round(filterOutputLowerFraction * numExamples);
        int upperNumExamples = (int) Math.round(filterOutputUpperFraction * numExamples);
        
        for (int e = 0; e < lowerNumExamples; e++) {
          useExamples[ (int) results[e][1]] = true;
        }
        for (int e = 0; e < upperNumExamples; e++) {
          useExamples[ (int) results[numExamples - 1 - e][1]] = true;
        }
      }
    }
    
    double errorSum = 0.0;
    int numPredictions = 0;
    double [] predictedOutputs = new double[numOutputs];
    
    for (int e = 0; e < numExamples; e++) {
      
      if (filterByPredictedOutput && !useExamples[e])
        continue;
      
      //errorSum += errorFunction.evaluate(examples, g, model);
      
      if (errorIsNegativeAverageActualOutput)
        errorSum -= examples.getOutputDouble(e, 0);
      else
        errorSum += errorFunction.evaluate(examples, e, predictionTable, predictedOutputs, ((Model) modelObject));
      
      numPredictions++;
    }
    
    double error;
    
    if (WeightErrorByTestingSetSize)
      error = errorSum;
    else
      if (WeightErrorByLogTestingSetSize)
        error = (errorSum / numPredictions) * Math.log(numPredictions);
      else
        error = errorSum / numPredictions;
    
    double[] utility = new double[1];
    utility[0] = error;
    
    if (reportAverageError) {
      synchronized (System.out) {
        if (exampleTable.getLabel() != null)
          System.out.println("(" + exampleTable.getLabel() + ")" +
           ErrorFunction.getErrorFunctionName(errorFunction.index) + " = " + utility[0]);
        else
          System.out.println(ErrorFunction.getErrorFunctionName(errorFunction.index) + " = " + utility[0]);
      }
    }
    
    // push outputs //
    
    String[] names = new String[1];
    names[0] = ErrorFunction.getErrorFunctionName(errorFunction.index);
    ParameterPoint objectivePoint = ParameterPointImpl.getParameterPoint(names, utility);
    //    objectivePoint.createFromData(names, utility);
    this.pushOutput(objectivePoint, 0);
    this.pushOutput(predictionTable, 1);
    
    invocationCount++;
    
  }
}
